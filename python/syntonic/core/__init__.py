"""Core module for Syntonic."""

from syntonic._core import (
    CorrectionLevel,
    FundamentalConstant,
    GoldenExact,
    Octonion,
    # Hypercomplex
    Quaternion,
    Sedenion,
    # Exact arithmetic
    Rational,
    RESConfig,
    ResonantEvolver,
    ResonantTensor,
    RESResult,
    Structure,
    SymExpr,
    SyntonicSoftmaxMode,
    SyntonicSoftmaxState,
    TensorStorage,
    # Winding
    WindingState,
    WindingStateIterator,
    _debug_stress_pool_take,
    compute_eigenvalues,
    compute_golden_weights,
    compute_knot_eigenvalues,
    compute_norm_squared,
    count_by_generation,
    count_windings,
    cuda_device_count,
    cuda_is_available,
    enumerate_windings,
    enumerate_windings_by_norm,
    enumerate_windings_exact_norm,
    filter_by_generation,
    heat_kernel_derivative,
    heat_kernel_trace,
    heat_kernel_weighted,
    knot_eigenvalue,
    knot_heat_kernel_trace,
    knot_spectral_zeta,
    knot_spectral_zeta_complex,
    linalg_bmm,
    # Linear algebra functions
    linalg_mm,
    linalg_mm_add,
    linalg_mm_corrected,
    # Linear algebra (generalized)
    linalg_mm_gemm,
    linalg_mm_golden_phase,
    linalg_mm_golden_weighted,
    linalg_mm_hn,
    linalg_mm_nh,
    linalg_mm_nt,
    linalg_mm_phi,
    linalg_mm_q_corrected_direct,
    linalg_mm_tn,
    linalg_mm_tt,
    linalg_phi_antibracket,
    linalg_phi_bracket,
    linalg_projection_sum,
    linalg_q_correction_scalar,
    partition_function,
    py_aggregate_syntony,
    # Physics operations (Geodesic Gravity Slide)
    py_apply_geodesic_slide,
    py_are_broadcastable,
    py_avg_pool2d,
    py_batch_cross_entropy_loss,
    py_batch_winding_syntony,
    py_broadcast_add,
    py_broadcast_div,
    py_broadcast_mul,
    # Broadcasting operations
    py_broadcast_shape,
    py_broadcast_sub,
    py_compute_snap_gradient,
    py_compute_winding_syntony,
    # Convolution operations
    py_conv2d,
    py_cross_entropy_loss,
    # Crystallization
    py_crystallize_with_dwell_legacy,
    py_e_star,
    py_estimate_syntony_from_probs,
    py_get_q_deficit,
    py_get_target_syntony,
    py_global_avg_pool2d,
    py_golden_decay_loss,
    py_golden_weight,
    py_golden_weights,
    py_inplace_abs,
    # In-place operations
    py_inplace_add_scalar,
    py_inplace_clamp,
    py_inplace_div_scalar,
    py_inplace_golden_weight,
    py_inplace_mul_scalar,
    py_inplace_negate,
    py_inplace_sub_scalar,
    py_is_square_free,
    py_linear_index,
    py_max_pool2d,
    py_mertens,
    # Number theory and syntony
    py_mobius,
    # Loss functions
    py_mse_loss,
    py_phase_alignment_loss,
    py_snap_distance,
    py_softmax,
    py_standard_mode_norms,
    py_syntonic_loss,
    py_syntony_loss,
    py_syntony_loss_srt,
    spectral_zeta,
    spectral_zeta_weighted,
    srt_apply_correction,
    srt_compute_syntony,
    srt_correction_factor,
    srt_dhsr_cycle,
    srt_e,
    srt_e8_batch_projection,
    srt_golden_gaussian_weights,
    srt_memory_resonance,
    srt_phi,
    srt_phi_inv,
    srt_pi,
    srt_pool_stats,
    srt_q_deficit,
    srt_reserve_memory,
    srt_scale_phi,
    srt_structure_dimension,
    srt_theta_series,
    srt_transfer_stats,
    srt_wait_for_resonance,
    syntonic_softmax,
    theta_series_derivative,
    # Spectral
    theta_series_evaluate,
    theta_series_weighted,
    theta_sum_combined,
)
from syntonic.core.device import (
    Device,
    cpu,
    cuda,
    device,
)
from syntonic.core.dtype import (
    DType,
    complex64,
    complex128,
    float32,
    float64,
    get_dtype,
    int32,
    int64,
    promote_dtypes,
    winding,
)
from syntonic.core.state import State, state

__all__ = [
    # State
    "State",
    "state",
    # Resonant
    "ResonantTensor",
    "RESConfig",
    "RESResult",
    "ResonantEvolver",
    # Syntonic Softmax
    "SyntonicSoftmaxMode",
    "SyntonicSoftmaxState",
    "syntonic_softmax",
    # DTypes
    "DType",
    "float32",
    "float64",
    "complex64",
    "complex128",
    "int32",
    "int64",
    "winding",
    "get_dtype",
    "promote_dtypes",
    # Devices
    "Device",
    "cpu",
    "cuda",
    "cuda_is_available",
    "cuda_device_count",
    "device",
    # Rust backend
    "TensorStorage",
    # SRT Tensor Operations
    "srt_scale_phi",
    "srt_golden_gaussian_weights",
    "srt_apply_correction",
    "srt_e8_batch_projection",
    "srt_theta_series",
    "srt_compute_syntony",
    "srt_dhsr_cycle",
    "srt_transfer_stats",
    "srt_reserve_memory",
    "srt_wait_for_resonance",
    "srt_pool_stats",
    "srt_memory_resonance",
    "_debug_stress_pool_take",
    # Physics operations (Geodesic Gravity Slide)
    "py_apply_geodesic_slide",
    # Linear algebra functions
    "linalg_mm",
    "linalg_mm_add",
    "linalg_mm_tn",
    "linalg_mm_nt",
    "linalg_mm_tt",
    "linalg_mm_hn",
    "linalg_mm_nh",
    "linalg_bmm",
    "linalg_mm_phi",
    "linalg_phi_bracket",
    "linalg_phi_antibracket",
    "linalg_mm_corrected",
    "linalg_mm_golden_phase",
    "linalg_mm_golden_weighted",
    "linalg_projection_sum",
    "linalg_mm_gemm",
    "linalg_mm_q_corrected_direct",
    "linalg_q_correction_scalar",
    "Structure",
    # Exact arithmetic
    "Rational",
    "GoldenExact",
    "FundamentalConstant",
    "CorrectionLevel",
    "SymExpr",
    "srt_phi",
    "srt_phi_inv",
    "srt_q_deficit",
    "srt_pi",
    "srt_e",
    "srt_structure_dimension",
    "srt_correction_factor",
    # Hypercomplex
    "Quaternion",
    "Octonion",
    "Sedenion",
    # Winding
    "WindingState",
    "WindingStateIterator",
    "enumerate_windings",
    "enumerate_windings_by_norm",
    "enumerate_windings_exact_norm",
    "count_windings",
    # Spectral
    "theta_series_evaluate",
    "theta_series_weighted",
    "theta_series_derivative",
    "heat_kernel_trace",
    "heat_kernel_weighted",
    "heat_kernel_derivative",
    "compute_eigenvalues",
    "compute_golden_weights",
    "compute_norm_squared",
    "spectral_zeta",
    "spectral_zeta_weighted",
    "partition_function",
    "theta_sum_combined",
    "count_by_generation",
    "filter_by_generation",
    "knot_eigenvalue",
    "compute_knot_eigenvalues",
    "knot_heat_kernel_trace",
    "knot_spectral_zeta",
    "knot_spectral_zeta_complex",
    # Number theory and syntony
    "py_mobius",
    "py_is_square_free",
    "py_mertens",
    "py_golden_weight",
    "py_golden_weights",
    "py_e_star",
    "py_compute_winding_syntony",
    "py_batch_winding_syntony",
    "py_aggregate_syntony",
    "py_standard_mode_norms",
    # Crystallization
    "py_crystallize_with_dwell_legacy",
    "py_snap_distance",
    "py_compute_snap_gradient",
    # Loss functions
    "py_mse_loss",
    "py_softmax",
    "py_cross_entropy_loss",
    "py_batch_cross_entropy_loss",
    "py_syntony_loss",
    "py_syntony_loss_srt",
    "py_get_target_syntony",
    "py_get_q_deficit",
    "py_phase_alignment_loss",
    "py_syntonic_loss",
    "py_estimate_syntony_from_probs",
    "py_golden_decay_loss",
    # Broadcasting operations
    "py_broadcast_shape",
    "py_are_broadcastable",
    "py_broadcast_add",
    "py_broadcast_mul",
    "py_broadcast_sub",
    "py_broadcast_div",
    "py_linear_index",
    # In-place operations
    "py_inplace_add_scalar",
    "py_inplace_mul_scalar",
    "py_inplace_sub_scalar",
    "py_inplace_div_scalar",
    "py_inplace_negate",
    "py_inplace_abs",
    "py_inplace_clamp",
    "py_inplace_golden_weight",
    # Convolution operations
    "py_conv2d",
    "py_max_pool2d",
    "py_avg_pool2d",
    "py_global_avg_pool2d",
]
